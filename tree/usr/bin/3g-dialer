#!/bin/bash
source /usr/lib/elive-tools/functions
el_make_environment

TEXTDOMAIN="3g-dialer"
export TEXTDOMAIN

guitool=zenity
lists="/usr/share/3g-dialer/templates"
logs="/tmp/.3g-dialer-${USER}-logs"
progress_file="/tmp/.3g-dialer-${USER}-progress"
connected="/tmp/.3g-dialer-${USER}-connected"
debug="yes"
timeout="timeout 30"



#===  FUNCTION  ================================================================
#          NAME:  providers_list_show_sorted
#   DESCRIPTION:  show the list of providers in the sorted form
#    PARAMETERS:  dir where the list of files of providers are located
#===============================================================================
providers_list_show_sorted(){
    local list
    list="$1"
    el_check_variables "$list"

   providers_list_show "$1" | sort | awk 'BEGIN{FS = "::"} {print $3"\n"$1"\n"$2}'
}

#===  FUNCTION  ================================================================
#          NAME:  kill_pid
#   DESCRIPTION:  kills forcely a pid
#    PARAMETERS:  pid
#===============================================================================
kill_pid(){
    local pid
    pid="$1"

    # only kill if exists
    if [[ -n "$pid" ]] ; then
        kill "$pid" 2>/dev/null 1>&2 || kill -9 "$pid" 2>/dev/null 1>&2
    fi
}
#===  FUNCTION  ================================================================
#          NAME:  providers_list_show_sorted
#   DESCRIPTION:  show the list of providers in the sorted form
#    PARAMETERS:  dir where the list of files of providers are located
#===============================================================================
providers_list_show(){
    local file provider country list
    list="$1"

    el_check_dirs "$list"
    el_check_dir_has_files "$list"

    for file in "${list}"/*__*
    do
        unset provider country
        file="${file##*/}" # basename

        provider="${file%__*}" # show first field
        country="${file##*__}" # show second field

        if [[ -n "$file" ]] && [[ -n "${provider}" ]] && [[ -n "${country}" ]] ; then
            echo "$country::$provider::$file"
        fi
    done
}


###########################################################################
#                                  Main                                   #
###########################################################################

main(){
    # pre {{{
    rm -f "$connected" "$progress_file" "$logs"

    # }}}

    case $1 in
        disconnect)
            killall wvdial 2>/dev/null && exit 0
            sleep 8
            killall -9 wvdial 2>/dev/null
            ;;
        connect)
            if [[ -f $HOME/.wvdialrc ]] ; then
                # XXX
                if grep -q "PIN=.*1234-example" $HOME/.wvdialrc ; then
                    sed -i "/[Dialer pin]/d" $HOME/.wvdialrc
                    sed -i "/Init1 = AT+CPIN=/d" $HOME/.wvdialrc
                fi

                provider="$( cat $HOME/.wvdialrc | grep "3G_NAME" | sed 's|^.*3G_NAME: ||g' )"

                { sleep 1 ; echo 10 ; sleep 1000 ; } \
                    | $guitool --progress --text=$"Connecting to:""${provider}..." --pulsate &

                pid_connecting_gui=$!

                if grep -q "\[Dialer pin\]" $HOME/.wvdialrc ; then
                    is_pin_needed="1"
                    device_pin_set "$@"
                fi

                : > $connected

                device_connect

                grep -q EXIT_NOW $connected && exit_me 1
                grep -q connected $connected && connected_wait_for_prompt "$@" || kill $pid_wvdial
            else

                configuration_select_new "$@"

            fi

            ;;
        *)
            configuration_select_new "$@"

            ;;
    esac


    #FIXME: Add a question about if connect, disconnect, or select a new provider, this question should be NOT launched if the variable emodule is set (in order to not needed it from the future module)

}
exit # FIXME remove


###########################################################################
#                                 Startup                                 #
###########################################################################












####################################################################
####################################################################
exit_me(){
    echo "PIDS: $pid_pin | $pid_wvdial ******" 1>&2

    kill_pid "$pid_pin"

    if [[ "$1" = "1" ]] ; then
        kill_pid "$pid_wvdial"
        ps aux | grep -v grep | grep wvdial 1>&2
    fi

    echo EXIT_NOW >> "$connected"
    rm -f "$connected" "$progress_file"

    exit 0
}
####################################################################
device_busy(){
   if [[ "$1" != "connect" ]] ; then
      $guitool --error --text=$"Looks like your device is busy or you have selected a wrong device, please disconnect and connect it again, then run this application once more"
   fi
}
####################################################################
device_pin_set(){
   if ! ((is_pin_needed)) ; then
       return
   fi

   kill_pid "$pid_pin"

   if [[ "$1" != "connect" ]]; then
      # show gui only if we are not connecting explicitly
      $guitool --info --text=$"Entering PIN code '$pin' in your modem, please wait" &
      pid_pin_gui=$!
   fi

   # FIXME: is needed "wvdial pin" when pin is required
   wvdial pin 2>$logs &
   pid_pin=$!

   while true
   do
       sleep 2
       if grep -qiE "(Device or resource busy|No such file or directory)" "$logs" ; then
           kill_pid "$pid_pin_gui"
           device_busy "$@"
           exit_me 1
       fi
       if grep -qE "(ERROR|Bad init string|operation not allowed|^OK)" "$logs" ; then
           kill_pid "$pid_pin_gui"
           break
       fi
       if grep -qE "(not specify a valid modem device)" "$logs" ; then
           kill_pid "$pid_pin_gui"
           $guitool --error --text=$"Your configuration doesn't include a valid device to use"
           # FIXME: detect device and try again
           break
       fi
   done

   sleep 26 # initializing modem...

   kill_pid "$pid_pin_gui"
   kill_pid "$pid_pin"

   unset pid_pin pid_pin_gui

   is_pin_accepted="yes"

   return
}
####################################################################
device_connect(){
    kill_pid "$pid_wvdial"

#   { { wvdial 2>&1 & } ; pid_wvdial=$! ; } | tee $logs 1>/dev/null # Si se aÃ±ade esta tuberia no entra en background asi que no usarlo
   echo 10 > "$progress_file"

   wvdial connect 2>$logs &
   pid_wvdial=$!

   # FIXME: cambiar a un sistema que no tenga que esperar siempre 14 segundos en total sino que vaya "leyendo el progreso"
   sleep 14

   if grep -q "EXIT_NOW" "$connected" 2>/dev/null ; then
       exit_me 1
   fi

   if grep -q "CONNECT" "$logs" ; then
      sleep 5
      echo "connected" >> "$connected"
   fi

   # FIXME: call a function to read these messages and include also the previous function ?
   if grep -q "NO CARRIER" "$logs" ; then
      $guitool --error --text="NO CARRIER: "$"This message means that there is a problem connecting to your provider. Please try to unplug and plug again your device and then wait 5 minutes before to try to connect, sometimes is needed that your device will start before to use, if this not works, try to move to a different place with a better signal."
   fi

   if grep -q "Modem not responding" "$logs" ; then
      $guitool --error --text=$"Modem is not responding, please try to unplug it and plug it in again"
      exit_me 1
   fi
   if grep -qiE "(Device or resource busy|No such file or directory)" "$logs" ; then
      device_busy
      kill_pid "$pid_connecting_gui"
   fi
   #echo 100 > $progress_file
   rm -f $progress_file
}
####################################################################
connected_wait_for_prompt(){
   : > $logs

   [[ "$debug" = "yes" ]] && cat "$logs" 1>&2

   if [[ "$1" != "connect" ]]; then
      # only show gui if we are not connecte explicitly
      { sleep 1 ; echo 10 ; sleep 1000 ; } | $guitool --progress --text="Connected... Waiting for data" --pulsate &
      pid_prompt_gui=$!
   fi

   while true
   do
      sleep 1
      if grep -qiE "(Device or resource busy|No such file or directory)" $logs ; then
          kill_pid "$pid_prompt_gui"
         device_busy "$@"
         exit_me 1
      fi
      if grep -qE "(local.*IP.*address|remote.*IP.*address|primary.*DNS|secondary.*DNS)" $logs ; then
         # ok, connected
          kill_pid "$pid_prompt_gui"
          kill_pid "$pid_connecting_gui"
         connected_successfully
         break
      fi
   done
}
####################################################################
connected_successfully(){
   $timeout $guitool --info --text=$"You have been successfully connected to the Internet."
   exit_me 0
}
####################################################################
configuration_select_new(){
if $guitool --question --text=$"Do you need to enter a PIN code for your modem? This is normally needed when you use a 3G-HSDPA modem connected via USB. It is not needed if you connect your phone to the computer" ; then
   pin="$( $guitool --entry --entry-text="1234-example" --text=$"Please enter your PIN code" || echo cancel )"
   is_pin_needed="1"
   if [[ ! "${#pin}" = "4" ]] || [[ "$pin" = *[^0-9]* ]] ; then
       # FIXME: warn about wrong ping set
      unset pin is_pin_needed
   fi
fi

full_list="$(providers_list_show_sorted "$lists" )"
selected="$( { echo -e "disconnect\n"$"Disconnect""\n"$"Disconnect your connection""\n""null\n"$"Any""\n"$"It is not listed here" ; echo "$full_list" ; sleep 1 ; echo "" ; } | $guitool --list --column="File" --column=$"Country" --column=$"Provider" --hide-column=1 --text=$"Select your desired Provider\nand Country to connect" --height="360" --width="300" || echo cancel )"

if [[ "$selected" = "cancel" ]]; then
    exit_me 0
fi

unset Username Password Apn Phone  Baud Modem Isdn

if [[ "$selected" = "disconnect" ]] ; then
   exit_me 1
fi

if [[ "$selected" = "null" ]] ; then
   Username=request
   Password=request
   # FIXME: change these names to something better
else
   source "${lists}/$selected"
fi

provider="${selected%%_*}"
# Note, more than one 'try' needs to be separed by a simple space

####################################################################
if [[ -z $Apn ]] ; then
   $guitool --info --text=$"The APN (Access Point Name) is the most important element that you need to know in order to connect to the Internet. If you do not know it, you can ask your Provider or search on google. It should be something like: internet, Internet, web.vodafone.de, movistar.es\n\nIt can be also an EMPTY value"
   Apn=$( $guitool --entry --text=$"Enter the APN (Access Point Name) of your Provider" || echo cancel )
fi

if [[ "$Apn" = "cancel" ]] ; then
    unset Apn
fi
#Note: If the APN is empty you should use 'empty' name:
if [[ "$Apn" = "" ]] ; then
    # FIXME change that value to an unique ID
    Apn="empty"
fi
Apn="$Apn internet"

if echo $Username | grep -q phonenumber ; then
   [[ -z "$phonenumber" ]] && phonenumber=$( $guitool --entry --text=$"Please enter your phone number" || echo cancel )
   Username=${Username/phonenumber/$phonenumber}
fi

if echo $Password | grep -q phonenumber ; then
   [[ -z "$phonenumber" ]] && phonenumber=$( $guitool --entry --text=$"Please enter your phone number" || echo cancel )
   Password=${Password/phonenumber/$phonenumber}
fi

if [[ "$Username" = "request" ]] ; then
    Username=$( $guitool --entry --text=$"Enter the Username to use" || echo dummy )
fi
if [[ "$Password" = "request" ]] ; then
    Password=$( $guitool --entry --text=$"Enter the Password to use" || echo dummy )
fi

if [[ -z $Baud ]] ; then
    # FIXME: autodetect with wvdialconf
   Baud=460800
fi

# FIXME: probar con mi yoigo a ver que pasa si no pongo ningun "phone" variable y dejo solo esto (empezando por el 777) a ver si magicamente se autoconecta a internet =)
if [[ -z $Phone ]] ; then
   Phone="*99# *99***1# #777 #888"
fi
####################################################################

# FIXME: Add the selector of bluetooth/usb modes (add a helper for bluetooth, and verify it too), that sets the variable $device

if [[ "$( ls -1 /dev/ttyACM* /dev/ttyUSB* 2>/dev/null | wc -l )" -gt "1" ]] ; then
    # FIXME: autodetect at every start, since the device can change
   device="$( ls -1 /dev/ttyACM* /dev/ttyUSB* 2>/dev/null | $guitool --list --text=$"Select the device from the list" --column=$"Device" || echo /dev/ttyACM0 )"
else
   device="$( ls -1 /dev/ttyACM* /dev/ttyUSB* 2>/dev/null | head -1 )"
fi

rm -f "$logs" 2>/dev/null


for phone in $Phone
do
   for apn in $Apn
   do
      for usernames in yes no
      do
         for dns in no yes
         do
            for stupid in No Yes
            do
#indent
cat > $HOME/.wvdialrc << EOF
[Dialer Defaults]
# 3G_NAME: $provider
Modem = $device
Username = '$Username'
Password = '$Password'

[Dialer connect]
Phone = $phone
Baud = $Baud
Stupid Mode = $stupid
Init = ATZ
Init2 = ATQ0 V1 E1 S0=0 &C1 &D2 +FCLASS=0
Init3 = AT+CGDCONT=1,"IP","$apn"
EOF

if [[ "$dns" = "yes" ]] ; then
   echo -e "Auto_DNS = no" >> $HOME/.wvdialrc
   [[ ! -z "$Dns1" ]] && echo -e "dns1 = $Dns1" >> $HOME/.wvdialrc
   [[ ! -z "$Dns2" ]] && echo -e "dns2 = $Dns2" >> $HOME/.wvdialrc
fi

if [[ "$usernames" = "no" ]] ; then
   sed -i "s/^Username.*$/Username = ''/" $HOME/.wvdialrc
   sed -i "s/^Password.*$/Password = ''/" $HOME/.wvdialrc
fi

if [[ "$apn" = "empty" ]] ; then
   sed -i "s/^Init3.*$/Init3 = AT+CGDCONT=1,\"IP\",\"\"/" $HOME/.wvdialrc
fi

if ((is_pin_needed)) ; then
   echo -e "\n[Dialer pin]" >> $HOME/.wvdialrc
   echo -e "Init1 = AT+CPIN=$pin" >> $HOME/.wvdialrc
fi


rm -f "$logs" "$progress_file" 2>/dev/null
sleep 1
touch "$progress_file" "$logs"
#echo -e "\tD: Try to connect"

if [[ "$is_pin_accepted" != "yes" ]] ; then
    device_pin_set
fi
if grep -q EXIT_NOW $connected 2>/dev/null ; then
    exit_me 0
fi

# FIXME: ugly as heaven
( while test -f $progress_file ; do cat $progress_file ; sleep 1 ; done ) | ( $guitool --progress --pulsate --auto-close --text=$"Elive is trying to connect using:\n\nPhone '${phone}'\nAPN '${apn}'\nWith Username: '${usernames}'\nWith auto-dns: '${dns}'\nUsing 'stupid mode': ${stupid}\n\nPlease be patient while waiting\nfor the attempts to be completed" || echo EXIT_NOW >> $connected ) &

device_connect

#( while test -f $progress_file ; do cat $progress_file ; sleep 1 ; done ) | ( $guitool --progress --pulsate --auto-close --auto-kill --text=$"Elive is trying to connect using:\n\nPhone '${phone}'\nAPN '${apn}'\nWith Username: '${usernames}'\nWith auto-dns: '${dns}'\nUsing 'stupid mode': ${stupid}\n\nPlease be patient while waiting\nfor the attempts to be completed" || echo cancel )
if grep -q EXIT_NOW $connected ; then
    exit_me 1
fi

#FIXME: separar el zenity del comando que parece no cerrarse correctamente... parsear los resultados de los logs para saber si seguir intentando o mostrar el mensaje de conectado
if grep -q connected "$connected" ; then
    connected_wait_for_prompt "$@"
else
    kill_pid "$pid_wvdial"
fi
            done
         done
      done
   done
done

if [[ -z $connected ]] ; then
    $guitool --error --text=$"It is not possible to connect. You can check your log file, ${logs} which contains a lot of useful information about why it has not been possible to be connected. You can also try the 'not listed here' option in the list, or edit the templates in /usr/share/3g-dialer/templates with the correct information"
fi


}









# vim: set foldmethod=marker :
